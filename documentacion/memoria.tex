\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage[dvipsnames]{xcolor}
\usepackage[spanish]{babel}
\usepackage[numbers]{natbib}

\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}

% redefine \VerbatimInput
\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}%
{
	fontsize=\footnotesize,
	%
	frame=lines,  % top and bottom rule only
	framesep=2em, % separation between frame and text
	rulecolor=\color{Gray},
	%
	% label=\fbox{\color{Black}data.txt},
	% labelposition=topline,
	%
}

\author{Ezequiel Santamaría Navarro}
\title{Trabajo fin de grado sobre la construcción de un entorno de aprendizaje pre-universitario para la programación.}


%\renewcommand{\abstractname}{Abstracto}
%\renewcommand{\contentsname}{Índice de contenido}
\renewcommand{\chaptername}{Parte}

\begin{document}
	\maketitle
	\tableofcontents
	
	\begin{abstract}
		Proceso de creación de un lenguaje sencillo, de un entorno de programación sin instalación y con herramientas para facilitar el desarrollo.
	\end{abstract}
	
	
	\chapter{Introducción}
	
	\section{Objetivo e intenciones de este trabajo}
	
	La enseñanza preuniversitaria de la programación consiste en enseñar a adolescentes y niños a poder pensar de forma lógica y abstracta. Esto conlleva un conjunto de problemas distintos al de la enseñanza a nivel universitario. Antes de la universidad no se puede asumir si los alumnos conocen o no ciertas partes de las matemáticas, si saben o no dibujo técnico, o incluso si entienden como funciona un espacio de coordenadas cartesianas.
	
	En mi caso concreto, la primera vez que empecé con un lenguaje de programación (uno que se use de forma profesional) fue Pascal con Delphi (en 2007). Fue mi hermano mayor quien me ayudó a instalar tanto el IDE como quien me explicó algunas directrices para empezar a hacer aplicaciones muy básicas.
	
	Durante dos años intenté hacer dos cosas muy concretas con Delphi que no conseguí y que me causaron frustración: dibujar (como en un lienzo, algunos gráficos) y conectar la aplicación a internet con otra copia de la aplicación.
	
	La sensación que he tenido desde entonces hasta hoy es que los lenguajes de programación están orientados a ser útiles desde la perspectiva de un ingeniero, pero no de facilitar el aprendizaje. 
	
	Por ello, mi objetivo sería conseguir que el proyecto cumpla los siguientes puntos:
	
	\begin{itemize}
		\item El lenguaje debe estar en la medida de lo posible en castellano, para no asumir que el alumno entiende inglés.
		\item El lenguaje tendrá tipos de datos con nombres comunes. Por ejemplo, se evitará el uso de Mapa y Vector, y se usarán nombres como Relación y Lista respectivamente.
		\item No debe asumir automáticamente conversiones de datos. Bajo mi perspectiva, el alumno debe ser consciente de que los datos tienen un representación que se puede convertir, pero que el ordenador no es inteligente y hay que dar órdenes explícitas.
		\item Que no requiera instalador, importantísimo para evitar frustraciones con el software. 
		\item Si fuera posible, integrable con la herramienta Descubre, para aprovechar el sistema de usuarios y de compartir los ejemplos que ya tiene.
		\item Que sea flexible para que los docentes puedan añadir funcionalidad, ampliando el conjunto de problemas, ejemplos, soluciones y aplicaciones.
	\end{itemize} 
	
	Estos son los puntos fundamentales que podrían simplificar el aprendizaje del desarrollo algorítmico y la programación.
	
	\section{Ideas extraídas de los distintos proyectos}
	
	Las ideas que más me han gustado y que desarrollo en el siguiente capítulo son:
	
	\begin{itemize}
		\item Editor y ejecución (compilación transparente) en una misma web como Descubre o CodeCombat.
		\item Un lenguaje propio simplificado como iJava. 
		\item Mezcla de imperativo y con objetos (aunque mayoritariamente imperativo) con una lista de subrutinas para dibujar como Processing.
		\item Intentar advertir de los errores de compilación con lenguaje sencillo evitando tecnicismos si es posible, como con el editor de Khan Academy
		\item Ofrecer un editor que ayude al alumno a escribir el código, sugiriendo nombres, autocompletando según el contexto...
	\end{itemize}
	
	%TODO: en vez de una sección por cada sistema de aprendizaje, hacer una sección con los sistemas
	% otro con los compiladores, y otro con los IDEs.
	
	\chapter{Estado del arte}
	
	\section{Entornos de aprendizaje a la programación}
	
	Investigando proyectos con puntos comunes a lo que busco, estos son los proyectos que he podido ver y me han sorprendido en algún o varios aspectos. Existen muchos más, pero estos ofrecen en conjunto lo mismo (o lo más destacable) que el resto.
	
	\subsection{Descubre}
	
	La herramienta Descubre, desarrollada por Juan Antonio Sánchez Laguna, Marcos Menárguez Tortosa, y Juan Antonio Martínez Navarro. 
	
	La herramienta se compone de:
	
	%TODO meter bibliografía y referencias de processing.
	
	\begin{itemize}
		\item Un editor de texto, derivado de CodeMirror.
		\item Un lenguaje de programación propio, derivado de Java, con un las funcionalidades de processing.
		\item Un entorno con un lienzo para dibujar y una salida para escribir texto.
		\item Un repositorio de usuarios y programas que permite copiar el código de otros para hacer clones. 
	\end{itemize}
	
	Con los siguientes puntos positivos:
	
	\begin{itemize}
		\item Entorno completo. Desde escribir el código hasta ver su resultado en la misma página.
		\item Sin instalación y sin necesidad de conocimientos sobre compilaciones.
		\item El lenguaje comparte sintaxis con C y Java, lo que es útil para avanzar más allá de la enseñanza. 
		\item La página tiene una lista de tutoriales y documentación sobre la funcionalidad de processing.
		\item Se puede clonar con facilidad el código de otros alumnos o docentes.
	\end{itemize}
	
	Y los siguientes puntos negativos:
	
	\begin{itemize}
		\item El lienzo es un poco pequeño. Se limita a 320x320.
		\item La sintaxis de iJava no es amigable para nuevos alumnos.
		\item La ejecución del código es síncrono. Esto reduce las posibilidades tecnológicas. Como por ejemplo, no se pueden cargar imágenes en tiempo de ejecución.
		\item No se puede rotar el lienzo, así que todos los dibujos deben estar alineados a los ejes de coordenadas.
		\item No se puede extender el lenguaje con el propio lenguaje. Es decir, no se puede escribir un módulo para que se incluya en otro código. Esta parte no es importante para el alumno, pero sí para el docente que quiera extender el lenguaje.
	\end{itemize}
	
	\hfill
	
	Acceso: \url{http://descubre.inf.um.es}
	
	\subsection{Codecombat}
	
	CodeCombat es un proyecto de código abierto para aprender a programar en base a un juego multijugador. Actualmente tiene varios problemas sencillos (que van creciendo en dificultad) para ir aprendiendo los mecanismos de los distintos lenguajes que ofrece, a la vez que vas ganando monedas para poder comprar objetos que ofrecen mayor funcionalidad (te permiten usar más métodos para resolver los distintos problemas).
	
	%TODO Añadir imágenes del proyecto y enlaces
	
	Se pueden destacar los siguientes puntos del proyecto:
	
	\begin{itemize}
		\item Gran conjunto de problemas a resolver que van creciendo en dificultad.
		\item Permite seleccionar entre Python, JavaScript, Clojure, CoffeScript y Lua.
		\item Acabado artístico profesional, así como una gran cantidad de objetos.
		\item Proyecto de código abierto.
		\item Traducido (parcialmente) a varios idiomas, entre los cuales se encuentra el español.
	\end{itemize}
	
	Sin embargo, el objetivo de esta plataforma es aprender resolviendo problemas concretos como moverse por un laberinto, o eliminando unos enemigos, pero no crear otras aplicaciones. Aún así, es una muy buena herramienta de aprendizaje.
	
	Como punto negativo destacaría que te obligan a programar en un lenguaje real, sin ofrecerte una alternativa amigable para nuevos alumnos. Que por defecto, Python, tiene problemas con la indentación obligatoria, que podría ser una barrera.
	
	Se puede probar sin registro. 
	
	\hfill
	
	Acceso: \url{http://codecombat.com}
	
	\subsection{Scratch}
	
	Scracth es un proyecto impulsado por el MIT para el desarrollo de pequeños proyectos con dibujos, animaciones y sonidos. 
	
	Se basa en programar unos módulos encajando unas piezas que equivalen a sentencias, instrucciones o elementos de control en un lenguaje
	por bloques, como si fuera un juego de Lego en dos dimensiones.
	
	El lenguaje y el editor tienen versión web y versión local, que se encuentra en paquetes como la Raspberry Pi. En la versión web, se pueden alojar proyectos para que 
	sean de dominio público y cualquier persona puede clonarlo para alterarlo a su gusto.
	
	De este proyecto cabe destacar la gran cantidad de usuarios, así como la interfaz y la posibilidad de no necesitar la web para hacer un proyecto. Además, los bloques que conforman el código están traducidos a varios idiomas, reduciendo la barrera de los alumnos que aprenden en castellano.
	
	La única pega que le veo al proyecto es que la programación es por bloques, y que la interfaz, en mi opinión, está enfocado a alumnos muy jóvenes (de edades entre 6 y 12 años). 
	
	\hfill
	
	Acceso: \url{https://scratch.mit.edu}
	
	\subsection{code.org}
	
	Code.org es una web con varios tipos niveles de problemas, donde hay un lienzo representando un problema. Los alumnos (recomendado de 4 a 18 años) resuelven unos problemas que crecen progresivamente en dificultad. A diferencia de codecombat, code.org utiliza un lenguaje basado en bloques como el de Scratch. 
	
	Los problemas son visualmente muy entretenidos (como los de codecombat), aunque más enfocados a alumnos más jóvenes (desde 4 años).
	
	Al igual que Scratch, esta web ofrece los bloques de código en castellano, y unos vídeos introductorios interesantes con subtítulos al español.
	
	La pega que le veo es la misma que a Scratch y Codecombat: solo ofrecen un mecanismo para resolver problemas, con una interfaz basada en bloques y con una temática enfocada a niños pequeños.
	
	\hfill
	
	Acceso: \url{http://code.org}
	
	\subsection{Khan Academy - Aprendiendo a dibujar con Javascript}
	
	En Khan Academy hay un conjunto de tutoriales para aprender JavaScript con el objetivo de dibujar en un lienzo como el de Descubre. Tiene muchos tutoriales y son todos interactivos y subtitulados al castellano.
	
	\hfill
	
	De aquí cabe destacar que el editor es muy interactivo. Permite la edición de casi cualquier valor con una especie de elemento visual. Además, el código se compila automáticamente (en el caso de javascript se podría evaluar directamente) y se pinta en el lienzo cada vez que el código cambia. 
	
	\hfill
	
	Acceso: 
	\href{https://es.khanacademy.org/computing/hour-of-code/hour-of-code-tutorial/p/intro-to-drawing}{Intro to Drawing}
	
	\section{Compiladores y analizadores escritos en javascript}
	
	\subsection{Jison - Bison para javascript}
	
	Jison es un proyecto escrito en Javascript que ofrece las herramientas similares a GNU Bison, un analizador de gramáticas libres de contexto de tipo LALR(1) \cite{bison}.
	
	Según mis cálculos (indicados más adelante) en el apartado \textit{Definición del lenguaje ZL} es necesario al menos un analizador que avance 3 tokens antes de conocer la derivación a realizar. Así que descarto Jison ya que no creo que sea suficientemente potente para analizar ZL. 
	
	Acceso:
	\href{https://github.com/zaach/jison}{Github de jison}	
	
	\subsection{Analizador descendente recursivo por prioridad de operadores}
	
	El analizador descendente (Top Down) por orden de prioridad de operadores (Operator Precedence) fue presentado por Vaughan Pratt en el año 73 \cite{acmtdop}. El analizador se basa en definir unos símbolos, unas expresiones y unos operadores (indicando su prioridad de forma numérica) con funciones recursivas que indican el comportamiento a la hora de ir avanzando recursivamente.
	
	
	En principio mi plan era utilizar este analizador como LL(3), pero mientras avanzaba con la implementación del análisis, ceñirse estrictamente al uso de este analizador era cada vez más difícil. 
	
	Sin embargo, este tipo de análisis ha inspirado la forma en la que he escrito el analizador sintáctico, usando reglas de derivación de forma recursiva donde en cada una de ellas se indica
	cómo se debe avanzar y cuál es el resultado generado. 
	
	Acceso:
	\href{http://javascript.crockford.com/tdop/tdop.html}{Texto de Douglas Crockford}
	
	\section{Editores de texto para Javascript y HTML}
	
	Lo primero que he encontrado ha sido el editor Codemirror. Es el mismo editor que usa el proyecto Descubre de la facultad. No me he dedicado en buscar otros editores porque este tiene
	todo lo que necesito para poder preparar el entorno, y además su API está muy bien documentada\cite{codemirrorapi}.
	
	Acceso:
	\href{http://codemirror.net/}{Página web oficial de codemirror.}
	
	\chapter{Análisis de objetivos y metodología}
	
	\section{Desarrollo de un entorno de programación}
	
	\subsection{Compilador del lenguaje ZL}
	
	\subsection{Editor de texto inteligente}
	
	\section{Definición del lenguaje ZL}
	
	%TODO: LL(3)
	%Conflictos LL(1) https://en.wikipedia.org/wiki/LL_parser#Solutions_to_LL.281.29_Conflicts
	
	\subsection{Descripción de la notación BNF ampliada}
	
	\subsection{Gramática BNF del lenguaje}
	La gramática del lenguaje en formato BNF se puede ver en el \hyperref[app:a]{Apéndice A}. De ella, cabe destacar de la gramática las 4 expresiones y los cuatro grupos de operadores, para poder definir correctamente el orden en el cuál los operadores se reducen. En la implementación no uso esa técnica para definir el orden de las operaciones, sino que una vez construido el árbol de la expresión, cambio sus ramas para que respeten el orden de los operadores. 
		
	\hfill
	
	Por otro lado, los número en el lenguaje permiten indicar base 2, 10 o 16 de la siguiente manera:
		
	\begin{itemize}
		\item $51966$ como número en base 10
		\item $51966|10$ como el mismo número
		\item $CAFE|16$ o $cafe|16$ como el mismo número en base hexadecimal.
		\item $1100101011111110|2$ como el número en base binaria.
	\end{itemize}
		
	
	\subsection{Descripción de la semántica}
	
		
	\chapter{Diseño y resolución del trabajo realizado}
	
	\section{Estructura del compilador para ZL}
	
	\subsection{Análisis léxico}
	
	\subsection{Análisis sintáctico}
	
	\subsection{Análisis semántico}
	
	\section{Editor inteligente - Autocompletado}
	
	\subsection{Determinando el contexto del cursor en el editor}
	
	\subsection{Algoritmos de similitud de nombres}
	
	\section{Triple plataforma - Web, Electron y NodeJS}
	
	\chapter{Conclusiones y vías futuras}
	
	\section{Posibles mejoras}
	
	\bibliographystyle{amsplain}
	\bibliography{biblio}
	
\iffalse
	
	\chapter{Lenguaje zl}
	\section{Introducción}
	El lenguaje está enfocado a cumplir las siguientes propiedades:
	
	\begin{itemize}
		\item Enfocado a parecerse sintácticamente al pseudocódigo en castellano, parecido al enseñado en la asignatura IP.
		\item Diferenciando los tipos de datos, sin hacer implícitas sus conversiones ni sus operaciones.
		\item Insensible a mayúsculas y minúsculas, 
		y aceptando tildes y eñes en los nombres.
		\item Con un único tipo de datos para representar números enteros y decimales (similar a Javascript).
	\end{itemize}

	\section{Subrutinas y datos}
	
	\section{Modulos y tipos}
	
	\section{Compilación}
	
	\subsection{Primera parte - Configuración}
	
	\subsection{Segunda parte - Sintaxis}
	
	\subsection{Tercera parte - Generación de tablas y entorno}
	
	\subsection{Cuarta parte - Comprobaciones semánticas}
	
	\subsection{Quinta parte - Generación de código JavaScript}
	
	\section{Ejecución}
	
	\subsection{Paso de objetos JavaScript al entorno}
	
	\chapter{Editor y entorno web}
	
	\section{Partes visuales del editor}
	
	\section{Descripción de funcionalidades}
	
	\chapter{Compilador sin entorno - NodeJS}
	
	\section{Compilación de código ZL a JavaScript sin dependencias web}
	
	\section{Pruebas unitarias}
	
	\chapter{Extendiendo el lenguaje}
	
	\section{Subrutinas primitivas - Código nativo}
	
	\section{Tipos de datos y sobrecarga de operadores} 
	
	\chapter{Ideas y ampliaciones futuras} 

\fi	

	\appendix
	\chapter{Notación BNF (extendida) del lenguaje} \label{app:a}
	
	\VerbatimInput{../sintaxis.txt}
	
\end{document}